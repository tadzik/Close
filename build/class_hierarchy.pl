#! /usr/bin/perl 
use warnings;
use strict;
use v5.8;
use integer;

use File::Find;
use File::Slurp;
use Getopt::Long;

our %Class_names;

our @Exclude_patterns = (
	'_INIT',
	'^Class::',
	'^Slam::Grammar::Actions$',
	'^Slam::(Block|Config|Node|Op|Stmts|Val|Var|VarList)',
	'^Slam::(Literal|Scope|Statement|Symbol::Name|SymbolTable|Type)$',
	'Visitor',
);

our $Header_re = qr{
\A (			# From start-of-string, 
	.*		# (including newlines), up to ..
	^		# From start-of-line
	( \s* )		# Collect the indentation-prefix whitespace
	\# \s*		# a comment with this program name, 
	class_hierarchy.pl \s+ 
	BEGIN	# and the word BEGIN
	(?: \s+ 	# and maybe CONTENTS + template
		CONTENTS \s+ ( [^\n]* \S ) 
	)?
	\s* $		# to end-of-LINE
)
}mosx;

our $Method_prefix = 'method _visit_';
our $Method_args = '($node)';

our $Trailer_re = qr{
^ ( [^\n]*		# From start-of-LINE
	\# \s*		# a comment with the program name
	class_hierarchy.pl \s+
	END		# and the word END
	.*		# and everything, including newlines
) \Z			# to end-of-string
}mosx;
	
sub build_class_list {
	my @dir_list = @_;
	find(\&get_class_names_from_file, @dir_list);
	my $exclude_re = join('|', @Exclude_patterns);
	$exclude_re = qr/$exclude_re/o;
	
	my @class_list =
		map { s/::/_/g; $_ }
		sort
		grep !/$exclude_re/,
		keys %Class_names;
	return @class_list;
}

sub build_method_declarations_section {
	my ($indentation, $method_contents, $class_names) = @_;
	
	$method_contents  = "DIE('Abstract method.');"
		unless $method_contents;
		
	my $pad_limit	= compute_method_padding_limit($class_names);
	my $method_body	= '{ ' . $method_contents . ' }';

	my @method_decls	= format_method_decls(
		$Method_prefix,
		$class_names, 
		$Method_args,
		$pad_limit,
		$method_body);
		
	my @section = (
		"",
		"# This section automatically generated by $ENV{USER} at "
			. gmtime() . " GMT",
		"",
	);
	push @section, @method_decls;
	push @section, "";
	
	my $section_text = join '', 
		map { $indentation . $_ . "\n" }
		@section;
		
	return $section_text;
}

sub compute_method_padding_limit {
	my ($class_names) = @_;
		
	# Figure out the "reasonable" max length - 90% of population
	my %length_freqs;
	for (@$class_names) {
		$length_freqs{length()}++;
	}

	my $majority = (scalar(@$class_names) * 90) / 100;
	my @lengths = sort keys %length_freqs;
	
	my $population	= 0;
	my $padding_limit	= 0;
	
	while ($population < $majority) {
		$padding_limit = shift @lengths;
		$population += $length_freqs{$padding_limit};
	}
	
	# 90% of methods are $padding_limit or shorter. 
	return $padding_limit;
}

sub format_method_decls {
	my ($prefix, $class_names, $suffix, $pad_limit, $method_body) = @_;
	
	# Adjust padding for full method name (prefix+class_name+suffix)
	$pad_limit += length($prefix) + length($suffix);
	$pad_limit += 8 - $pad_limit % 8;	# Round to tab stop
	
	my @method_decls = 
		map { my $method_name = $prefix . $_ . $suffix;
			my $len = length($method_name); 
			my $tabs = ($len < $pad_limit)
				? "\t" x (($pad_limit - $len + 7) / 8)
				: ' ';
			$method_name . $tabs . $method_body;
		}
		@$class_names;
	return @method_decls;
}

sub get_class_names_from_file {
	return unless /\.nqp$/;
	
	open(NQP, $_) or return;	
	my @lines = <NQP>;
	close(NQP);
	
	chomp @lines;
	
	map { $Class_names{$_} = 1; }
		map { s/^.*(class|module)\s+\b(\w+(::\w+)+).*$/$2/x; $_ }
		grep /(?: \b class \b | \b module \b ) \s+ \w+ :: /x, @lines;
	
}

sub get_overridden_methods {
	my ($text) = @_;
	my %overrides;
	my $visit_method_re = qr{
		^ \s* 			# Optional indentation
		method \s+ 		# 'method' space
		_visit_(\S+) 		# _visit_Foo
		\s* \( 			# (
	}mox;

	while ($text =~ /$visit_method_re/g) {
		$overrides{$1}++;
	}	
	
	if (keys %overrides) {
		print scalar(keys %overrides),
			" methods overridden. These will not be generated.\n";
		print "\t" . join("\n\t", sort keys %overrides) . "\n";
	}
	
	return %overrides;
}

sub update_methods_in_file {
	my ($filename, $class_names) = @_;
	my $contents = read_file($filename);
	write_file($filename . '.PRE', $contents);
	
	# Header = everything before code-generation break.
	$contents			=~ m/$Header_re/;
	my $header			= $1;
	my $indentation_prefix	= $2;
	my $method_contents	= $3;
	
	# Trailer = everything after code-generation break.
	$contents			=~ m/$Trailer_re/;
	my $trailer			= $1;
	
	my %overrides = get_overridden_methods($header . "\n" . $trailer);

	my @update_classes =
		grep { ! $overrides{$_} }
		@$class_names;
		
	my $method_declarations = build_method_declarations_section(
		$indentation_prefix,
		$method_contents, 
		\@update_classes);
	
	my $new_content = $header 
		. $method_declarations
		. $trailer;
	
	write_file($filename, $new_content);
}

our $List_classes = 0;

GetOptions(
	'list' => \$List_classes,
) or exit(1);

my @files = @ARGV;
my @class_names = build_class_list('.');

if (@files) {
	for (@files) {
		print("Updating method list in file: $_\n");
		update_methods_in_file($_, \@class_names);
	}
}
elsif ($List_classes) {
	print "Found ", scalar(@class_names), " classes\n";
	print join("\n", @class_names) . "\n";
}
else {
	print "I don't know what you want.\n";
	exit 1;
}

exit 0;