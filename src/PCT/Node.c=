# $Id: $

# FIXME: Don't know what to do about classes in a nsp other than 'close'. WTF? Emit them.
hll parrot;

class PCT::Node
	:phylum(P6object)
{
	pmc init(pmc children ..., pmc adverbs ... :named)
		:method
	{
		foreach (pmc child : children) {
			push self, child;
		}

		pmc value;
		pmc key;
		pmc iter = new Iterator, adverbs;

		while (iter) {
			key = shift iter;
			value = iter[key];
			# Does this work?
			self.(find_method self, key)(value);
			asm {{
				$P0 = find_method self, key
				self.$P0(value);
			}};
		}

		return self;
	}

	pmc new(pmc children ..., pmc adverbs ... :named)
		:method
	{
		pmc obj = new self.HOW().parrotclass;
		obj.init(children :flat, adverbs :flat :named);
		return obj;
	}

	pmc clone()
		:method()
	{
		return clone self;
	}

	void unshift(pmc value)
		:method
	{
		unshift self, value;
	}

	pmc shift()
		:method
	{
		return shift self;
	}

	void push(pmc value)
		:method
	{
		push self, value;
	}

	pmc pop()
		:method
	{
		return pop self;
	}

	pmc iterator()
		:method
	{
		pmc iter = new Iterator, self.list();
		iter = 0;
		return iter;
	}

	void node(pmc node)
		:method
	{
		if (node) {
			if (isa node, PCT::Node) {
				self.source = node.source;
				self.pos = node.pos;
			}
			else if (isa node, PGE::Match) {
				self.source = node.'$.target';
				self.pos = node.from();
			}
			else {
				die(concat "Don't know how to save info from node of type ", typeof node);
			}
		}
	}

	pmc name(pmc value :optional)
		:method
	{
		tailcall self.attr('name', value, has_value);
	}

	pmc attr(str attrname, pmc value, int has_value, pmc default = new Undef)
		:method
	{
		if (has_value) {
			return self[attrname] = value;
		}
		else {
			value = self[attrname];
			return value == null ? default : value;
		}
	}

	str unique(str fmt = '')
		:method
	{
		return concat fmt, serno++;
	}

	int isa(pmc type)
		:method
	{
 		return self.HOW().isa(self, type);
 	}

	int get_bool()
		:method
		:vtable('get_bool')
	{
		# Maybe: asm {{ .return (1) }};
		return 1;
	}
}
