# $Id$

=VERSION 

$Rev$

=cut

=rule extern_statement

An C<extern_statement> is a statement that may appear outside a function. 
Because "normal" statements are assumed to be part of a namespace or class 
init block, all of them are permitted. In addition, a C<namespace_definition>
may only appear outside a function.

=cut

rule extern_statement {
	| <namespace_definition>	{*} #= namespace_definition
#	| <namespace_directive>
	| <local_statement>		{*} #= local_statement
}

=rule local_statement

A I<local_statement> is a statement that may appear in a local scope -- that is,
inside a class or function declaration. The 'usual' coding statements are here,
such as loops, goto, if/then/else, expressions, etc.

=cut

rule local_statement {
	[ <labeled_stmt>		{*} #= labeled_stmt
	| <null_stmt>		{*} #= null_stmt
	| <compound_stmt>		{*} #= compound_stmt
	| <conditional_stmt>	{*} #= conditional_stmt
	| <iteration_stmt>		{*} #= iteration_stmt
	| <jump_stmt>		{*} #= jump_stmt
	| <declaration_statement>	{*} #= declaration_statement
	| <expression_statement>	{*} #= expression_statement
	]
	|| [ <!before '}' | $ > <.panic: "Statement expected"> ]
}

rule null_stmt {
	';'
	{*}
}

=head4 Expression Statement

Expression statement represent most of your programs. Any expression, defined above, followed by a
semi-colon[;] is an expression statement.

=cut

rule expression_statement {
	<expression>
	[ ';' || <panic: "Missing ';' at end of expression statement" > ]
	{*}
}

rule declaration_statement {
	<declaration> ';'
	{*}
}

rule compound_stmt {
	'{'
		$<item>=<local_statement>
	[ '}' || <panic: "Missing closing '}' in compound block" > ]
	{*}
}

rule conditional_stmt {
	$<kw>=[ 'if' | 'unless' ]
	[ '(' || <panic: "if/unless statements must have '(' ')' around test expression" > ]
	<expression>
	[ ')' || <panic: "missing ')' at end of test expression" > ]
	$<then>=<local_statement>
	[ 'else' $<else>=<local_statement> ]?
	{*}
}

rule jump_stmt {
	| 'goto' <label=bareword>
		[ ';' || <panic: "Missing ';' at end of goto statement" > ]
		{*}	#= goto
	| 'return' <retval=expression>? 
		[ ';' || <panic: "Missing ';' at end of return statement" > ]
		{*} #= return
	| 'tailcall' <retval=postfix_expr> 
		[ ';' || <panic: "Missing ';' at end of tailcall statement" > ]
		{*} #= tailcall
	# | continue [ <loop> ]? ';'         {*} #= continue
	# | break [ <loop> ]? ';'             {*} #= break
}

rule labeled_stmt {
	| [ <label> ]+
		[ <local_statement>		{*} #= label
		|| <panic: "A statement label must be followed by a statement" >
		]

	# | 'case' <label=expression> ':' <local_statement> {*} #= case
	# | 'default' ':' <local_statement>       {*} #= default
}

token label {
	<bareword> ':' <!before ':'>
	{*}
}

rule iteration_stmt {
	| <do_while_stmt>	{*} #= do_while_stmt
	| <while_do_stmt>	{*} #= while_do_stmt
	| <foreach_stmt>	{*} #= foreach_stmt
}

rule foreach_stmt {
	<.t_foreach>
		[ '(' || <panic: "Missing opening '(' in foreach statement" > ]
		{*} #= index
		[	[ <index=declaration> ::
			| <index=short_ident> ::
			]
		|| <panic: "foreach (item: list) iterations must use a local variable" >
		]
		[ ':' || <panic: "Missing ':' in foreach (item: list) statement" > ]
		<list=expression>
		[ ')' || <panic: "Missing closing ')' in foreach statement" > ]
	{*} #= open
	<local_statement>
	{*} #= close
}

token t_foreach { 'foreach' >> }

rule do_while_stmt {
	'do' <local_statement>
	$<kw>=[ 'while' | 'until' ]
	[ '(' || <panic: "do...while/until statements must have '(' ')' around test expression" > ]
	<expression>
	[ ')' || <panic: "missing ')' at end of test expression" > ]
	[ ';' || <panic: "Missing ';' at end of do...while/until statement" > ]
	{*}
}

rule while_do_stmt {
	$<kw>=[ 'while' | 'until' ]
	[ '(' || <panic: "while/until ... statements must have '(' ')' around test expression" > ]
	<expression>
	[ ')' || <panic: "missing ')' at end of test expression" > ]
	<local_statement>
	{*}
}

