# $Id$

#grammar close::Grammar is PGE::Grammar;

=rule cv_qualifier

One of the access qualifiers C<const> or C<volatile>. This rule is used in both
L<#type_specifier> and L<#declarator> matching.

=cut

rule cv_qualifier {
	| <token=CONST>		{*}
	| <token=VOLATILE>	{*}
}

=rule dclr_adverb

Matches the adverbs that may modify a declarator.

=cut

rule dclr_adverb {
	| <token=ADV_ANON>	{*}
	| <token=ADV_INIT>	{*}
	| <token=ADV_LOAD>	{*}
	| <token=ADV_MAIN>	{*}
	| <token=ADV_MULTI> '(' ~ ')' <signature=string_literal: ')'> {*}
	| <token=ADV_REG_CLASS> '(' ~ ')' <register_class=QUOTED_LIT> {*}
	# | <token=ADV_METHOD> (handled by 'method' keyword?)
	| <token=ADV_VTABLE>	{*}
}

=rule dclr_alias

Matches a declarator alias, as in C<extern int '$Line' alias line;>

=cut

rule dclr_alias {
	<.ALIAS> <alias=new_alias_name> {*}
}

=rule dclr_array_or_hash

Matches one of three possible syntaxes for declaring an array or hash. 

=item # C<[ % ]>

A hash is declared with a percent sign (the Perl hash sigil) inside brackets.

=item # C<[ ]>

A pair of empty brackets indicates an array of unspecified, indeterminate, or
variable size.

=item # C<[ expression ]>

An expression inside brackets indicates an array of fixed size, determined by
the value of expression at the time of initialization.

=cut

rule dclr_array_or_hash {
	| $<hash>='%'		{*} #= decl_hash_of
	| <size=expression>		{*} #= decl_array_of
	|				{*} #= decl_array_of
}

=rule dclr_atom

Matches either a C<declarator_name> (as in 'extern int Foo::x', the 'Foo::x'
part) or another C<declarator> nested in parentheses.

=cut

rule dclr_atom {
	| :dba('nested declarator')
	    '(' ~ ')' <declarator>	{*} #= declarator
	| <declarator_name>	{*} #= declarator_name
}

=rule dclr_pointer

Matches a star ('*') -- the Close "pointer to something" indicator -- optionally 
followed by C<cv_qualifier>s.

=cut

rule dclr_pointer {
	$<token>='*' <cv_qualifier>*	{*}
}

=rule dclr_postfix

Matches either an array or hash declaration (C<decl[%]>), or a function's 
parameter declaration list (C<decl(int a, string b)>) after a declarator.

=cut

rule dclr_postfix {
	| :dba('function parameter list')
	    '(' ~ ')' <parameter_list>		{*} #= parameter_list
	| :dba('hash or array declaration')
	    '[' ~ ']' <dclr_array_or_hash>	{*} #= dclr_array_or_hash
}

rule declaration {
	<specifier_list> <symbol=declarator_part> [ ','  <symbol=declarator_part> ]*	
	{*}
}

=rule declarator

A declarator is that part of the declaration specific to a single name. The 
declarator includes the symbol name, as well as any prefix indicating
the symbol is a pointer, and any suffix indicating the symbol is a function,
array, or hash.

=cut

rule declarator {
	# * const	->	myvar		-> (int x, string y)
	<dclr_pointer>* <dclr_atom> <dclr_postfix>*
	{*}
}

rule declarator_part {
	<declarator>
	<dclr_alias>?
	[ <adverbs=dclr_adverb> ]*
	{*} #= declarator
	[ '=' <initializer=expression>
		{*} #= initializer
	|  <?before '{' >	
		{*} #= open_block
		<body=compound_statement>
		{*} #= close_block
	]?
	{*} #= done
}

=rule namespace_alias_declaration

Declares an alias for a namespace. 

=cut

rule namespace_alias_declaration {
	<.NAMESPACE> <namespace_name> 
	<.ALIAS> <alias=new_alias_name>
	{*}
}

=rule param_adverb

Matches the adverbs that may appear in a parameter declaration.

=cut

# :named('foo')
rule param_adverb {
	| <token=ADV_NAMED> ['(' ~ ')' <named=QUOTED_LIT> ]? {*}
	| <token=ADV_OPTIONAL>	{*}
	| <token=ADV_SLURPY>		{*}
}

=rule parameter_declaration

Matches a single parameter declaration, with optional trailing tokens.

=cut

rule parameter_declaration {
	<specifier_list>
	<parameter=declarator> 
	[ <adverbs=param_adverb> ]*
	<default=expression>?
	{*}
}

rule parameter_list {
	{*} #= open
	[ <param_list=parameter_declaration> [ ',' | <?before ')'> ] ]*
	{*} #= close
}


=rule specifier

Matches any form of type specifier. Storage class specifiers (keywords),
type specifiers (builtins, or user defined types), and function specifiers
(more keywords). Matches only one specifier -- the rule must be used in a
qualified context with '*' or '+'.

=cut

rule specifier {
	| <tspec_function_attr>	{*} #= tspec_function_attr
	| <tspec_storage_class>	{*} #= tspec_storage_class
	| <tspec_type_specifier>	{*} #= tspec_type_specifier
}

rule specifier_list {
	<specifier>+ {*}
}

rule tspec_function_attr {
	| <token=INLINE>		{*}
	| <token=METHOD>	{*}
}

rule tspec_storage_class {
	| <token=_BUILTIN>	{*}
	| <token=DYNAMIC>	{*}
	| <token=EXTERN>		{*}
	| <token=LEXICAL>		{*}
	| <token=REGISTER>	{*}
	| <token=STATIC>		{*}
	| <token=TYPEDEF>	{*}
}

rule tspec_type_name {
	<type_name>	 	{*}
}

rule tspec_type_specifier {
#	| <tspec_builtin_type>	{*} #= tspec_builtin_type
#	| <class_specifier>			{*} #= class_specifier
	| <cv_qualifier>		{*} #= cv_qualifier
#	| <enum_specifier>			{*} #= enum_specifier
#	| <elaborated_type_specifier>	{*} #= elaborated_type_specifier
#	| <typename_specifier>		{*} #= typename_specifier
	# type-name is the only pattern that does not have a keyword.
	| <tspec_type_name>		{*} #= tspec_type_name
}

rule using_namespace_directive {
	<.USING> {{ say "Using namespace directive?" }}
<.NAMESPACE> <namespace=namespace_path>
	{*}
}

rule using_declaration {
	<.USING> <qualified_identifier>
	# FIXME: Add alias. (General alias rule needed.)
}
