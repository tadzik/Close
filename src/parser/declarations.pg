# $Id$

=rule cv_qualifier

One of the access qualifiers C<const> or C<volatile>. This rule is used in both
L<#type_specifier> and L<#declarator> matching.

=cut

rule cv_qualifier {
	| <token=CONST>		{*}
	| <token=VOLATILE>	{*}
}

=rule dclr_alias

Matches a declarator alias, as in C<extern int '$Line' alias line;>

=cut

rule dclr_alias {
	<.ALIAS> <alias=new_alias_name> {*}
}

=rule dclr_alias_init

An dclr_alias_init is a C<dclr_declarator> optionally followed by an 
C<dclr_initializer>.

=cut

rule dclr_alias_init {
	<dclr_declarator> <dclr_alias>? <dclr_initializer>?
	{*}
}

=rule dclr_array_or_hash

Matches one of three possible syntaxes for declaring an array or hash. 

=item # C<[ % ]>

A hash is declared with a percent sign (the Perl hash sigil) inside brackets.

=item # C<[ ]>

A pair of empty brackets indicates an array of unspecified, indeterminate, or
variable size.

=item # C<[ expression ]>

An expression inside brackets indicates an array of fixed size, determined by
the value of expression at the time of initialization.

=cut

rule dclr_array_or_hash {
	| $<hash>='%'		{*}
	| <expression>		{*}
	|				{*}
}

=rule dclr_atom

Matches either a C<declarator_name> (as in 'extern int Foo::x', the 'Foo::x'
part) or another C<dclr_declarator> nested in parentheses.

=cut

rule dclr_atom {
	| :dba('nested declarator')
	    '(' ~ ')' <dclr_declarator>	{*}
	| <declarator_name>	{*}
}

=rule dclr_declarator

A dclr_declarator is that part of the declaration specific to a single name. The 
dclr_declarator includes the symbol name, as well as any prefix indicating
the symbol is a pointer, and any suffix indicating the symbol is a function,
array, or hash.

=cut

rule dclr_declarator {
	# * const	->	myvar		-> (int x, string y)
	<dclr_pointer>* <dclr_atom> <dclr_postfix>*
	{*}
}

=rule dclr_init_list

A list of at least one C<dclr_alias_init>, separated by commas.

=cut

rule dclr_init_list {
	<item=dclr_alias_init> [ ',' <item=dclr_alias_init> ]*
}

rule dclr_initializer {
	'=' <expression>		{*}
}

rule dclr_param_list {
	{*} #= open
	[ <param_list=parameter_declaration> [ ',' | <?before ')'> ] ]*
	{*} #= close
}

=rule dclr_pointer

Matches a star ('*') -- the Close "pointer to something" indicator -- optionally 
followed by C<cv_qualifier>s.

=cut

rule dclr_pointer {
	$<token>='*' <cv_qualifier>*	{*}
}

=rule dclr_postfix

Matches either an array or hash declaration (C<decl[%]>), or a function's 
parameter declaration list (C<decl(int a, string b)>) after a dclr_declarator.

=cut

rule dclr_postfix {
	| :dba('function parameter list')
	    '(' ~ ')' <dclr_param_list>		{*} #= dclr_param_list
	| :dba('hash or array declaration')
	    '[' ~ ']' <dclr_array_or_hash>		{*} #= dclr_array_or_hash
}

=rule function_definition

Matches a function header with attached curly block.

=cut

rule function_definition {
	<specifier>+
	<dclr_declarator> <dclr_alias>?
	<compound_statement>
	{*}
}

=rule namespace_alias_declaration

Declares an alias for a namespace. 

=cut

rule namespace_alias_declaration {
	<.NAMESPACE> <namespace_name> 
	<.ALIAS> <alias=new_alias_name>
	{*}
}

=rule namespace_definition

A namespace definition is a block that assigns a namespace path to all the
declarations contained in the block.

    namespace Foo {
        void bark();	// Defines Foo::bark();
    }

=cut

rule namespace_definition {
	<EXTERN>? <.NAMESPACE> <namespace_path> 
	'{'
		{*} #= open
		<extern_statement>*
	'}'
	{*} #= close
}

=rule param_adverb

Matches the adverbs that may appear in a parameter declaration.

=cut

rule param_adverb {
	| <token=ADV_NAMED>		{*}
	| <token=ADV_OPTIONAL>	{*}
	| <token=ADV_SLURPY>		{*}
}

=rule parameter_declaration

Matches a single parameter declaration, with optional trailing tokens.

=cut

rule parameter_declaration {
	<specifier>+
	<parameter=dclr_declarator> 
	[ $<adverbs>=<param_adverb> ]*
	<initializer=dclr_initializer>?
	{*}
}

=rule specifier

Matches any form of type specifier. Storage class specifiers (keywords),
type specifiers (builtins, or user defined types), and function specifiers
(more keywords). Matches only one specifier -- the rule must be used in a
qualified context with '*' or '+'.

=cut

rule specifier {
	| <tspec_function_attr>	{*} #= tspec_function_attr
	| <tspec_storage_class>	{*} #= tspec_storage_class
	| <tspec_type_specifier>	{*} #= tspec_type_specifier
}

=rule symbol_declaration

Matches the standard C-like variable patterns: 

    int foo;
    int a = 1, b = 2;
    extern void f();

=cut

rule symbol_declaration {
	<specifier>+		{*} #= specifiers
	<dclr_init_list>	{*} #= declarators
}

=rule tspec_builtin_type

Matches any of the Close builtin types.

=cut

rule tspec_builtin_type {
	| <token=AUTO>		{*}
	#| <token=CLASS>		{*} # Really?
	| <token=FLOAT>		{*}
	| <token=INT>		{*}
	| <token=PMC>		{*}
	| <token=STRING>		{*}
	| <token=VOID>		{*}
}

rule tspec_function_attr {
	| <token=INLINE>		{*}
	| <token=METHOD>	{*}
}

rule tspec_storage_class {
	| <token=DYNAMIC>	{*}
	| <token=EXTERN>		{*}
	| <token=LEXICAL>		{*}
	| <token=REGISTER>	{*}
	| <token=STATIC>		{*}
	| <token=TYPEDEF>	{*}
}

rule tspec_type_specifier {
	| <tspec_builtin_type>	{*} #= tspec_builtin_type
#	| <class_specifier>			{*} #= class_specifier
	| <cv_qualifier>		{*} #= cv_qualifier
#	| <enum_specifier>			{*} #= enum_specifier
#	| <elaborated_type_specifier>	{*} #= elaborated_type_specifier
#	| <typename_specifier>		{*} #= typename_specifier
	# type-name is the only pattern that does not have a keyword.
	| <tspec_type_name>		{*} #= tspec_type_name
}

token tspec_type_name {
	<type_name> {*}
}

rule using_namespace_directive {
	<.USING> <.NAMESPACE> <namespace=namespace_name>
}

rule using_declaration {
	<.USING> <qualified_identifier>
	# FIXME: Add alias. (General alias rule needed.)
}

rule declarator_part {
	<dclr_declarator>
	<dclr_alias>?
	[ '=' <dclr_initializer>
	| <body=compound_statement>
	]?
	{*}
}
	
rule declaration {
	<specifier>+		
	{*} #= specifiers
	<symbol=declarator_part>
	[ ',' <symbol=declarator_part> ]*	
	{*} #= declarators
}
