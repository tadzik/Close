# $Id$

=VERSION 

$ Rev: $

=cut

grammar close::Grammar is PCT::Grammar;

rule TOP {
	<translation_unit> {*}
}

rule translation_unit {
	{{
		$P0 = box 1
		set_global '$Top_of_file', $P0
	}}
	{*} #= start
	<extern_statement>*
	[ $ || <panic: 'Syntax error'> ]
	{*} #= finish
}

rule namespace_block {
	[ 'namespace' <namespace_name>  ';' ]?
	{*} #= open
	<declaration>*
	{*} #= close
}

# Note that a namespace_name is not the same as a long_ident.
# Namespace names are "that part of the long_ident before the
# trailing identifier." That means that '::' is a valid namespace
# name, but not a valid long_ident.
#

token namespace_name {
	[ [ $<root>='::' ]? <part=bareword> :: [ '::' <part=bareword> ]*
	| [ $<root>='::' ]
	| '[' ::  [$<root>='::' ]? [ <part=string_lit> [ ';' <part=string_lit> ]* ]?
		[ ']' || <panic: 'Missing "]" in namespace name'> ]
	]
	{*}
}

# A long identifier is a variable, function, or class name that is qualified
# with namespace information. Valid forms are Foo::Bar::baz (Perl-style),
# and [ 'Foo' ; 'Bar' ; 'baz' ] (Parrot-style) for names whose namespaces are
# within their HLL tree. For rooted names (names which may refer to
# other HLL namespaces), valid forms are ::perl6::Foo::Bar::baz and
# [ :: 'perl6' ; 'Foo' ; 'Bar' ; 'baz' ].
#
# Note that the form ::x is considered to be a name at the top of the HLL
# namespace tree. That is, ::x is the same as ::close::x. There is no syntax
# for specifying symbol names at the top level. (Note that namespace
# names are not long identifiers.)
#
token long_ident {
	[ [ $<root>='::' ]?
		<part=bareword> :: [ '::' <part=bareword> ]*
	| '[' ::
		[ $<root>='::' ]?
		<part=string_lit> [ ';' <part=string_lit> ]*
		[ ']'
		|| <panic: 'Missing "]" in long identifier'>
		]
	]
	{*}
}

rule adverbs {
	[ <adverb> ]*
	{*}
}

rule adverb {
	| [ $<extends>='extends' <args=long_ident> [ ',' <args=long_ident> ]* ] 
	  {*}
	| [
		<t_adverb>		# matches ":something", with no space inside
		[ '(' 
			[ <args=string_lit> [ ',' <args=string_lit> ]* 
			| <signature=string_literal: ')' >	# Support :multi(_, A)
			]
		')' ]?
	]
	{*}
}

token t_adverb {
	| ':' <ident> 
	| $<ident>='...'	# An alias for slurpy
	| $<ident>='?'	# An alias for optional:  func(a, b, c? = 1)
}

token ws {
	| <?{{								# Cache ws results.
		$P0 = get_global '$!ws'
		if null $P0 goto noshort
		$P1 = $P0.'to'()
		$P2 = match.'to'()
		if $P1 != $P2 goto noshort
		.return(1)
	  noshort:
		set_global '$!ws', match
		.return(0)
	}}>
	| <!ww> <.WS_ALL>+
	| <.WS_ALL>*
}

token WS_ALL {
	[ \s+
	| '#' \N* [ \n | $ ]		# Deprecated
	| <.POD>			# Deprecated
	| '/*' .*? '*/'			# <.C_BLOCK_COMMENT>
	| '//' \N* [ \n | $ ]		# <.C_LINE_COMMENT>
	]
}

regex POD {
	^^ '='	[ [ 'cut' \h*: | 'end' [\h\N*]? ]
		| 'for' [ \h \N+: ] \n [ \N+\n ]*:
		| \w\N*: \n .*? \n '=' [ 'cut' \h*: | 'end' [\h\N*]? ]
		]
		[ \n | $ ]
}

#token C_BLOCK_COMMENT {
#	'/*' .*? '*/'
#}

#token C_LINE_COMMENT {
#	'//' \N* [ \n | $ ]
#}

token string_lit {
	[ '\'' <string_literal: '\''> '\''
	| '"' <string_literal: '"'> '"'
	]
	{*}
}

token integer_lit {
	[
	| 0	[ 'b' <[01]>+	[ _ <[01]>+ ]*
		| 'o' <[0..7]>+	[ _ <[0..7]>+ ]*
		| 'd' \d+			[ _ \d+ ]*
		| 'x' <xdigit>+	[ _ <xdigit>+ ]*
		]
	| \d+ [ _ \d+ ]*
	]
	{*}
	<.integer_u_or_l_suffix>?
}

token integer_u_or_l_suffix {
	| <[Uu]> [ <[Ll]> <[Ll]>? ]?
	| <[Ll]> <[Ll>? <[Uu]>?
}

token float_lit {
	[				'.' \d+[_\d+]*	<.Escale>?
	| \d+[_\d+]*	'.' \d+[_\d+]*	<.Escale>?
	| \d+[_\d+]*					<.Escale>
	]
	{*} #= float_lit
}

token Escale {
	<[Ee]> <[ + \- ]>? \d+[_\d+]*
}

token short_ident {
	[ <id=bareword> | <id=string_lit> ]
	{*}
}

token bareword {
	<!reserved_word>
	<.ident>
}

token reserved_word {
	<.keyword>
}

token keyword {
	| <.language_element>
	| <.builtin_function>
}

token language_element {
	[ 'asm'
	| 'const'
	| 'else'
	| 'extern'
	| 'for'
	| 'foreach'
	| 'if'
	# | 'lexical'
	| 'register'
	| 'return'
	#| 'self' Can't be prohibited, else it were a function. 
	| 'sub'
	| 'tailcall'
	| 'unless'
	| 'void'
	] >>
}

token builtin_function {
	[ 'null'
	] >>
}

# rule expression is defined in expressions.pg
# rule built_in is defined in builtins.pg

## rule hll_block {
## 	[ 'hll' <hllname=short_ident> ';'
## 	|| <?{{
## 		$P0 = get_global '$Top_of_file'
## 		.return ($P0)
## 		}}>
## 	]
## 	{{
## 		$P0 = box 1
## 		set_global '$Top_of_hll_block', $P0
## 		$P0 = box 0
## 		set_global '$Top_of_file', $P0
## 	}}
## 	{*} #= open
## 	<namespace_block>+
## 	{*} #= close
## }

