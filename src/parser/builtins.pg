# Defines builtin functions/operators/terms for close.

rule built_in {
	[ <?before <t_builtin> >  
	|| <.fail> 
	]
	
	# This brace required because otherwise the paragraph above is
	# considered part of the || expression below, and when <fail>
	# happens, the ||panic kicks in.
	[ 
		[ <builtin_concat>	{*} #= builtin_concat
		| <builtin_isa>	{*} #= builtin_isa
		| <builtin_isnull>	{*} #= builtin_isnull
		| <builtin_new>	{*} #= builtin_new
		| <builtin_null>	{*} #= builtin_null
		| <builtin_pop>	{*} #= builtin_pop
		| <builtin_push>	{*} #= builtin_push
		| <builtin_shift>	{*} #= builtin_shift
		| <builtin_unshift>	{*} #= builtin_unshift
		] 
	|| <.panic: "Invalid syntax for builtin expression">
	]
}

# Hoist the constant strings up for a quickie check of all builtins.
token t_builtin {
	[ 'concat'
	| 'isa'
	| 'isnull'
	| 'new'
	| 'null'
	| 'pop'
	| 'push'
	| 'shift'
	| 'unshift'
	] 
	>>		# End of word
	<!before '('>	# Not a function call
}

# if ( isa x, Class ) {... }
rule builtin_isa { 'isa' <obj=expression> ',' <class=expression> {*} }

# if ( isnull x ) {...}
rule builtin_isnull { 'isnull' <expression> {*} }

# x = new Iterator, foo
# FIXME: Add "new expression" support.
rule builtin_new { 'new' <classname=long_ident> [ ',' <args1=expression> ]? {*} }

# null
token builtin_null { 'null' {*} }

# x = pop array;
rule builtin_pop { 'pop' <arr=expression> {*} }

# push array, x, y, z;
rule builtin_push {  
	'push'
	[ <arr=expression>
	|| <.panic: "First argument to built-in 'push' must be an array expression" > 
	]
	[ ',' <val=expression>  [ ',' <val=expression> ]* {*} 
	|| <.panic: "Invalid number of arguments to built-in 'push': minimum is 2" > 
	]
}

# x = shift array
rule builtin_shift { 'shift' <arr=expression> {*} }

# unshift array, x, y, z;
rule builtin_unshift { 'unshift' <arr=expression> ',' <val=expression> [ ',' <val=expression> ]* {*} }

# x = concat s0, s1, s2, ... , sn;
rule builtin_concat { 'concat' <str=expression> ',' <val=expression> [ ',' <val=expression> ]* {*} }

